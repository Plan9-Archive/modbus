# status

Under development.

# intro

Mobdus support for Limbo programs.

The Modbus CRC algorithm uses a CRC-16 calculated using the polynomial
0xA001.  In order to use the table generated by the crc(2) module, the
additional function is required:

	crc16(crcs : ref CRCstate, buf : array of byte, nb : int) : int
	{
		n := nb;
		if (n > len buf)
			n = len buf;
		crc := crcs.crc;
		tab := crcs.crctab;
		for (i := 0; i < n; i++) {
			crc = (crc >> 8) ^ tab[int(byte crc ^ buf[i])];
		}
		crcs.crc = crc;
		return crc;
	}


The crc(2) seed reg value is not utilized.  Modbus CRC-16 resets the crc
state to 0xFFFF instead of the default 0x0000.  The following is an
example of using the code:

	crc = load Crc Crc->PATH;
	crc_state = crc->init(0xA001, 1);
	
	b := array[] of {
		byte 16r01,
		byte 16r03, byte 16r00, byte 16r00, byte 16r00, byte 16r02,
	};
	
	crc_state.crc = 16rFFFF;
	c := crc16(crc_state, b, len b);



A timing test was performed to to determine the difference bewteen using
the crc initialized table and just calculating the new crc using on each
pass.  The testing environment was running emu in interpreted mode (on OS X)
on a 2.66 GHz Intel Core i7.  The test granularity was constrained by
sys->millisec() so a loop was performed one million times for each crc test
using a byte array of [0x01, 0x03, 0x00, 0x00, 0x00, 0x02].  The timing
results for an average call time were:

	2.517 µs for crc16
	6.871 µs for notab_crc16


# install

# license & author

All files are Copyright (C) 2011, Corpus Callosum Corporation.
